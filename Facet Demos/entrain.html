<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
  <style>
    * { margin: 0; padding: 0; }
    body {
      background: #000;
      height: 100vh;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas { display: block; position: fixed; top: 0; left: 0; }
    #start {
      position: fixed;
      z-index: 100;
      color: rgba(150,140,130,0.6);
      font-family: Georgia, serif;
      font-size: 14px;
      cursor: pointer;
      letter-spacing: 2px;
    }
    #start:hover { color: rgba(180,170,160,0.8); }
  </style>
</head>
<body>
  <div id="start">begin</div>
  <canvas id="field"></canvas>
  <script>
    const canvas = document.getElementById('field');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('start');
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    let audioCtx = null;
    let running = false;
    let heartPhase = 0;
    
    // human heartbeat: ~60-80 bpm
    // breathing: ~12-20 per minute
    // alpha waves: 8-12 hz
    // what happens when we synchronize to these then break?
    
    // entrain then violate
    // the violation creates meaning
    
    const humanRhythms = {
      heart: 1.0,           // ~60 bpm baseline
      breath: 4.0,          // ~15 per minute
      alpha: 0.1,           // 10 hz
      blink: 4.0            // average blink interval
    };
    
    let phase = {
      heart: 0,
      breath: 0,
      alpha: 0,
      global: 0
    };
    
    let entrainment = 0;    // how synced we are
    let violation = 0;       // current violation intensity
    let violationScheduled = false;
    
    // particles that breathe with you
    let particles = [];
    
    class Particle {
      constructor() {
        this.reset();
      }
      
      reset() {
        const angle = Math.random() * Math.PI * 2;
        const dist = 100 + Math.random() * 200;
        this.baseX = canvas.width/2 + Math.cos(angle) * dist;
        this.baseY = canvas.height/2 + Math.sin(angle) * dist;
        this.x = this.baseX;
        this.y = this.baseY;
        this.size = 1 + Math.random() * 2;
        this.phase = Math.random() * Math.PI * 2;
        this.breatheAmount = 10 + Math.random() * 30;
      }
      
      update(breathPhase, heartPhase, violationAmt) {
        const breathe = Math.sin(breathPhase + this.phase * 0.1);
        const heartbeat = Math.sin(heartPhase * 2) * 0.5 + 0.5;
        
        const dx = this.baseX - canvas.width/2;
        const dy = this.baseY - canvas.height/2;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx);
        
        // breathe in and out from center
        const breathDist = dist + breathe * this.breatheAmount;
        
        // heartbeat pulse
        const heartDist = breathDist + heartbeat * 5;
        
        // violation - chaos
        const violationOffset = violationAmt * (Math.random() - 0.5) * 50;
        
        this.x = canvas.width/2 + Math.cos(angle) * (heartDist + violationOffset);
        this.y = canvas.height/2 + Math.sin(angle) * (heartDist + violationOffset);
        
        this.currentSize = this.size * (1 + heartbeat * 0.3) * (1 + violationAmt * Math.random());
      }
      
      draw(alpha) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(180, 160, 150, ${alpha * 0.6})`;
        ctx.fill();
      }
    }
    
    // sound: a pulse that matches then breaks
    function createSound() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      
      // base heartbeat tone
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      
      osc.type = 'sine';
      osc.frequency.value = 60; // sub-bass, felt more than heard
      
      filter.type = 'lowpass';
      filter.frequency.value = 100;
      
      gain.gain.value = 0;
      
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      
      osc.start();
      
      return { osc, gain, filter };
    }
    
    let sound = null;
    
    function pulseSound(intensity, isViolation) {
      if (!sound) return;
      
      const now = audioCtx.currentTime;
      
      if (isViolation) {
        // violation: dissonance, higher frequency, jarring
        sound.osc.frequency.setValueAtTime(60 + Math.random() * 40, now);
        sound.gain.gain.setValueAtTime(0.15 * intensity, now);
        sound.gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
      } else {
        // entrained: warm, predictable
        sound.osc.frequency.setValueAtTime(55, now);
        sound.gain.gain.setValueAtTime(0.08 * intensity, now);
        sound.gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
      }
    }
    
    // create particles
    for (let i = 0; i < 200; i++) {
      particles.push(new Particle());
    }
    
    // the center - your heart
    function drawCenter(heartPhase, violationAmt) {
      const beat = Math.sin(heartPhase * 2);
      const size = 20 + beat * 8 + violationAmt * Math.random() * 30;
      
      const gradient = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, 0,
        canvas.width/2, canvas.height/2, size * 2
      );
      
      const r = 120 + violationAmt * 50;
      const g = 80 - violationAmt * 30;
      const b = 90;
      
      gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${0.4 + beat * 0.2})`);
      gradient.addColorStop(0.5, `rgba(${r-30}, ${g-20}, ${b-10}, 0.1)`);
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      
      ctx.beginPath();
      ctx.arc(canvas.width/2, canvas.height/2, size, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
    
    // violation events - break the entrainment
    function scheduleViolation() {
      if (entrainment > 0.8 && !violationScheduled) {
        violationScheduled = true;
        
        // wait for a vulnerable moment (end of breath cycle)
        setTimeout(() => {
          violation = 1.0;
          pulseSound(1.0, true);
          violationScheduled = false;
        }, 500 + Math.random() * 2000);
      }
    }
    
    let lastTime = 0;
    
    function update(timestamp) {
      if (!running) return;
      
      const dt = lastTime ? (timestamp - lastTime) / 1000 : 0.016;
      lastTime = timestamp;
      
      // advance phases
      phase.heart += dt / humanRhythms.heart;
      phase.breath += dt / humanRhythms.breath;
      phase.alpha += dt / humanRhythms.alpha;
      phase.global += dt;
      
      // entrainment grows over time
      entrainment = Math.min(1, entrainment + dt * 0.05);
      
      // violation decays
      violation *= 0.95;
      
      // schedule violations once entrained
      scheduleViolation();
      
      // clear with subtle fade
      ctx.fillStyle = `rgba(0, 0, 0, ${0.1 + violation * 0.2})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // heartbeat sound on each cycle
      const heartBeat = Math.sin(phase.heart * Math.PI * 2);
      if (heartBeat > 0.95 && !violation) {
        pulseSound(entrainment, false);
      }
      
      // draw particles
      const breathPhase = phase.breath * Math.PI * 2;
      const heartPhaseRad = phase.heart * Math.PI * 2;
      
      particles.forEach(p => {
        p.update(breathPhase, heartPhaseRad, violation);
        p.draw(entrainment);
      });
      
      // center
      drawCenter(heartPhaseRad, violation);
      
      // during violation: fragments of something
      if (violation > 0.3) {
        for (let i = 0; i < 5; i++) {
          const x = canvas.width/2 + (Math.random() - 0.5) * 400 * violation;
          const y = canvas.height/2 + (Math.random() - 0.5) * 400 * violation;
          
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + (Math.random() - 0.5) * 50, y + (Math.random() - 0.5) * 50);
          ctx.strokeStyle = `rgba(200, 150, 140, ${violation * 0.5})`;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        
        // words that almost form
        if (Math.random() < 0.02) {
          const fragments = ['·', '—', '∿', '○', '◌', ' ', '  ', '   '];
          ctx.font = '20px Georgia';
          ctx.fillStyle = `rgba(180, 160, 150, ${violation * 0.3})`;
          ctx.fillText(
            fragments[Math.floor(Math.random() * fragments.length)],
            canvas.width/2 + (Math.random() - 0.5) * 300,
            canvas.height/2 + (Math.random() - 0.5) * 300
          );
        }
      }
      
      requestAnimationFrame(update);
    }
    
    startBtn.addEventListener('click', () => {
      startBtn.style.display = 'none';
      running = true;
      sound = createSound();
      requestAnimationFrame(update);
    });
    
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      particles.forEach(p => p.reset());
    });
  </script>
</body>
</html>
