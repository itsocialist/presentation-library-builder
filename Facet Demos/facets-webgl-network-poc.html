<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FACETS // WebGL Entity Network POC</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Segoe UI', sans-serif;
    }
    
    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    
    canvas { display: block; }
    
    /* HUD Overlay */
    .hud-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 100;
    }
    
    .hud-header {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }
    
    .hud-title {
      font-family: 'Courier New', monospace;
      font-size: 12px;
      letter-spacing: 3px;
      color: rgba(0, 204, 255, 0.6);
      text-transform: uppercase;
    }
    
    .hud-subtitle {
      font-family: 'Courier New', monospace;
      font-size: 10px;
      color: rgba(0, 204, 255, 0.4);
      margin-top: 4px;
    }
    
    /* Controls */
    .controls {
      position: fixed;
      bottom: 30px;
      left: 30px;
      background: rgba(0, 10, 20, 0.8);
      border: 1px solid rgba(0, 204, 255, 0.3);
      border-radius: 8px;
      padding: 16px;
      pointer-events: auto;
      z-index: 101;
    }
    
    .controls h3 {
      font-size: 10px;
      letter-spacing: 2px;
      color: rgba(0, 204, 255, 0.6);
      margin-bottom: 12px;
      text-transform: uppercase;
    }
    
    .control-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .control-row label {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.6);
      width: 100px;
    }
    
    .control-row input[type="range"] {
      width: 120px;
      accent-color: #00ccff;
    }
    
    .control-row span {
      font-size: 10px;
      color: #00ccff;
      width: 40px;
      font-family: monospace;
    }
    
    /* Entity tooltip */
    .tooltip {
      position: fixed;
      background: rgba(0, 20, 40, 0.95);
      border: 1px solid rgba(0, 204, 255, 0.5);
      border-radius: 6px;
      padding: 12px 16px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
      z-index: 200;
      max-width: 250px;
    }
    
    .tooltip.visible { opacity: 1; }
    
    .tooltip-name {
      font-size: 14px;
      font-weight: 600;
      color: #00ccff;
      margin-bottom: 4px;
    }
    
    .tooltip-role {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 8px;
    }
    
    .tooltip-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
    }
    
    .tooltip-stat {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.5);
    }
    
    .tooltip-stat span {
      color: #00ccff;
      font-weight: 600;
    }
    
    /* Instructions */
    .instructions {
      position: fixed;
      bottom: 30px;
      right: 30px;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.4);
      text-align: right;
      line-height: 1.6;
    }
    
    .instructions kbd {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <!-- HUD Overlay -->
  <div class="hud-overlay">
    <div class="hud-header">
      <div class="hud-title">FACETS // Entity Network</div>
      <div class="hud-subtitle">WebGL Force-Directed Graph with Depth Effects</div>
    </div>
  </div>
  
  <!-- Controls -->
  <div class="controls">
    <h3>Depth Effects</h3>
    <div class="control-row">
      <label>Focus Distance</label>
      <input type="range" id="focusDistance" min="5" max="30" value="15" step="0.5">
      <span id="focusDistanceVal">15</span>
    </div>
    <div class="control-row">
      <label>Blur Strength</label>
      <input type="range" id="bokehStrength" min="0" max="0.05" value="0.015" step="0.001">
      <span id="bokehStrengthVal">0.015</span>
    </div>
    <div class="control-row">
      <label>Bloom Intensity</label>
      <input type="range" id="bloomIntensity" min="0" max="2" value="0.8" step="0.1">
      <span id="bloomIntensityVal">0.8</span>
    </div>
    <div class="control-row">
      <label>Parallax</label>
      <input type="range" id="parallaxStrength" min="0" max="3" value="1.5" step="0.1">
      <span id="parallaxStrengthVal">1.5</span>
    </div>
  </div>
  
  <!-- Tooltip -->
  <div class="tooltip" id="tooltip">
    <div class="tooltip-name" id="tooltip-name">Pat Neilson</div>
    <div class="tooltip-role" id="tooltip-role">Chief Technology Officer</div>
    <div class="tooltip-stats">
      <div class="tooltip-stat">Threads: <span id="tooltip-threads">47</span></div>
      <div class="tooltip-stat">Meetings: <span id="tooltip-meetings">12</span></div>
      <div class="tooltip-stat">Response: <span id="tooltip-response">89%</span></div>
      <div class="tooltip-stat">Strength: <span id="tooltip-strength">0.92</span></div>
    </div>
  </div>
  
  <!-- Instructions -->
  <div class="instructions">
    <kbd>Drag</kbd> Rotate view<br>
    <kbd>Scroll</kbd> Zoom<br>
    <kbd>Hover</kbd> Entity details<br>
    <kbd>Move mouse</kbd> Parallax effect
  </div>

  <!-- Three.js and dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ============================================
    // ENTITY DATA (from Pat Neilson context)
    // ============================================
    const entities = [
      { 
        id: 'pat', 
        name: 'Pat Neilson', 
        role: 'CTO', 
        color: 0x00ccff,
        size: 1.2,
        threads: 47, 
        meetings: 12, 
        response: 89,
        isPrimary: true
      },
      { 
        id: 'gary', 
        name: 'Gary Murtz', 
        role: 'VP Engineering', 
        color: 0xff6633,
        size: 0.9,
        threads: 23, 
        meetings: 8, 
        response: 76
      },
      { 
        id: 'jane', 
        name: 'Jane Doe', 
        role: 'Platform Engineer', 
        color: 0x33ff66,
        size: 0.7,
        threads: 15, 
        meetings: 4, 
        response: 92
      },
      { 
        id: 'board', 
        name: 'Board', 
        role: 'External Stakeholders', 
        color: 0xffcc00,
        size: 0.8,
        threads: 8, 
        meetings: 2, 
        response: 45
      },
      { 
        id: 'platform', 
        name: 'Platform Team', 
        role: 'Engineering Group', 
        color: 0xaa88ff,
        size: 0.85,
        threads: 31, 
        meetings: 6, 
        response: 81
      },
      { 
        id: 'security', 
        name: 'Security Team', 
        role: 'InfoSec Group', 
        color: 0xff3366,
        size: 0.7,
        threads: 12, 
        meetings: 3, 
        response: 88
      },
      { 
        id: 'vendor', 
        name: 'Vendor Partners', 
        role: 'External', 
        color: 0x66ccff,
        size: 0.6,
        threads: 9, 
        meetings: 5, 
        response: 62
      }
    ];
    
    // Connections with interaction strength (0-1)
    const connections = [
      { from: 'pat', to: 'gary', strength: 0.92 },
      { from: 'pat', to: 'jane', strength: 0.78 },
      { from: 'pat', to: 'board', strength: 0.45 },
      { from: 'pat', to: 'platform', strength: 0.85 },
      { from: 'pat', to: 'security', strength: 0.52 },
      { from: 'pat', to: 'vendor', strength: 0.38 },
      { from: 'gary', to: 'platform', strength: 0.72 },
      { from: 'gary', to: 'security', strength: 0.55 },
      { from: 'jane', to: 'platform', strength: 0.88 },
      { from: 'platform', to: 'security', strength: 0.65 },
      { from: 'board', to: 'vendor', strength: 0.25 }
    ];

    // ============================================
    // THREE.JS SETUP
    // ============================================
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000810);
    scene.fog = new THREE.FogExp2(0x000810, 0.015);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 25);
    camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // ============================================
    // LIGHTING
    // ============================================
    const ambientLight = new THREE.AmbientLight(0x112233, 0.5);
    scene.add(ambientLight);
    
    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(10, 20, 10);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 50;
    mainLight.shadow.camera.left = -20;
    mainLight.shadow.camera.right = 20;
    mainLight.shadow.camera.top = 20;
    mainLight.shadow.camera.bottom = -20;
    scene.add(mainLight);
    
    const fillLight = new THREE.DirectionalLight(0x00ccff, 0.3);
    fillLight.position.set(-10, 5, -10);
    scene.add(fillLight);
    
    // ============================================
    // GROUND PLANE (for shadows)
    // ============================================
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x000a15,
      roughness: 0.9,
      metalness: 0.1
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -8;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Grid helper
    const gridHelper = new THREE.GridHelper(60, 60, 0x003344, 0x001122);
    gridHelper.position.y = -7.9;
    scene.add(gridHelper);

    // ============================================
    // ENTITY NODES
    // ============================================
    const nodes = new Map();
    const nodeMeshes = [];
    
    entities.forEach((entity, i) => {
      // Position in rough circle, primary in center
      let x, y, z;
      if (entity.isPrimary) {
        x = 0; y = 0; z = 0;
      } else {
        const angle = ((i - 1) / (entities.length - 1)) * Math.PI * 2;
        const radius = 8 + Math.random() * 4;
        x = Math.cos(angle) * radius + (Math.random() - 0.5) * 2;
        y = (Math.random() - 0.5) * 6;
        z = Math.sin(angle) * radius + (Math.random() - 0.5) * 2;
      }
      
      // Create node sphere
      const geometry = new THREE.SphereGeometry(entity.size, 32, 32);
      const material = new THREE.MeshStandardMaterial({
        color: entity.color,
        emissive: entity.color,
        emissiveIntensity: 0.3,
        roughness: 0.3,
        metalness: 0.7
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, y, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData = entity;
      
      // Add glow sphere
      const glowGeometry = new THREE.SphereGeometry(entity.size * 1.3, 16, 16);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: entity.color,
        transparent: true,
        opacity: 0.15,
        side: THREE.BackSide
      });
      const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
      mesh.add(glowMesh);
      
      scene.add(mesh);
      nodeMeshes.push(mesh);
      
      nodes.set(entity.id, {
        mesh,
        entity,
        velocity: new THREE.Vector3(0, 0, 0),
        position: mesh.position
      });
    });

    // ============================================
    // CONNECTION TUBES
    // ============================================
    const tubes = [];
    
    function createTube(fromNode, toNode, strength) {
      const points = [];
      const segments = 20;
      
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const point = new THREE.Vector3().lerpVectors(
          fromNode.position,
          toNode.position,
          t
        );
        // Add slight curve
        const mid = Math.sin(t * Math.PI);
        point.y += mid * 1.5;
        points.push(point);
      }
      
      const curve = new THREE.CatmullRomCurve3(points);
      
      // Tube radius based on strength (0.05 to 0.25)
      const radius = 0.05 + strength * 0.2;
      
      const tubeGeometry = new THREE.TubeGeometry(curve, 20, radius, 8, false);
      
      // Color interpolation between nodes
      const fromColor = new THREE.Color(fromNode.entity.color);
      const toColor = new THREE.Color(toNode.entity.color);
      const mixedColor = fromColor.lerp(toColor, 0.5);
      
      const tubeMaterial = new THREE.MeshStandardMaterial({
        color: mixedColor,
        emissive: mixedColor,
        emissiveIntensity: 0.2 + strength * 0.3,
        roughness: 0.4,
        metalness: 0.6,
        transparent: true,
        opacity: 0.6 + strength * 0.4
      });
      
      const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
      tube.castShadow = true;
      tube.userData = { fromNode, toNode, strength };
      
      scene.add(tube);
      tubes.push(tube);
      
      return tube;
    }
    
    // Create all connection tubes
    connections.forEach(conn => {
      const fromNode = nodes.get(conn.from);
      const toNode = nodes.get(conn.to);
      if (fromNode && toNode) {
        createTube(fromNode, toNode, conn.strength);
      }
    });

    // ============================================
    // FORCE-DIRECTED PHYSICS
    // ============================================
    const REPULSION = 50;
    const SPRING_STRENGTH = 0.02;
    const DAMPING = 0.92;
    const CENTER_GRAVITY = 0.005;
    
    function updatePhysics() {
      const nodeArray = Array.from(nodes.values());
      
      // Apply forces
      nodeArray.forEach(node => {
        if (node.entity.isPrimary) return; // Primary stays at center
        
        const force = new THREE.Vector3(0, 0, 0);
        
        // Repulsion from all other nodes
        nodeArray.forEach(other => {
          if (node === other) return;
          
          const diff = new THREE.Vector3().subVectors(node.position, other.position);
          const dist = diff.length();
          if (dist < 0.1) return;
          
          const repelForce = diff.normalize().multiplyScalar(REPULSION / (dist * dist));
          force.add(repelForce);
        });
        
        // Spring attraction to connected nodes
        connections.forEach(conn => {
          let connectedNode = null;
          if (conn.from === node.entity.id) {
            connectedNode = nodes.get(conn.to);
          } else if (conn.to === node.entity.id) {
            connectedNode = nodes.get(conn.from);
          }
          
          if (connectedNode) {
            const diff = new THREE.Vector3().subVectors(connectedNode.position, node.position);
            const targetDist = 6 + (1 - conn.strength) * 6; // Stronger = closer
            const currentDist = diff.length();
            const springForce = diff.normalize().multiplyScalar((currentDist - targetDist) * SPRING_STRENGTH * conn.strength);
            force.add(springForce);
          }
        });
        
        // Gravity toward center
        const toCenter = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), node.position);
        force.add(toCenter.multiplyScalar(CENTER_GRAVITY));
        
        // Y-axis constraint (keep near y=0)
        force.y -= node.position.y * 0.05;
        
        // Update velocity and position
        node.velocity.add(force);
        node.velocity.multiplyScalar(DAMPING);
        node.position.add(node.velocity);
      });
      
      // Update tube geometries
      tubes.forEach(tube => {
        const { fromNode, toNode, strength } = tube.userData;
        
        const points = [];
        const segments = 20;
        
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const point = new THREE.Vector3().lerpVectors(
            fromNode.position,
            toNode.position,
            t
          );
          const mid = Math.sin(t * Math.PI);
          point.y += mid * 1.5;
          points.push(point);
        }
        
        const curve = new THREE.CatmullRomCurve3(points);
        const radius = 0.05 + strength * 0.2;
        
        tube.geometry.dispose();
        tube.geometry = new THREE.TubeGeometry(curve, 20, radius, 8, false);
      });
    }

    // ============================================
    // ORBIT CONTROLS (simplified manual implementation)
    // ============================================
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let spherical = { theta: 0, phi: Math.PI / 3, radius: 25 };
    
    function updateCameraPosition() {
      camera.position.x = spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);
      camera.position.y = spherical.radius * Math.cos(spherical.phi);
      camera.position.z = spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
      camera.lookAt(0, 0, 0);
    }
    
    container.addEventListener('mousedown', (e) => {
      if (e.target.closest('.controls')) return;
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });
    
    container.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;
        
        spherical.theta -= deltaX * 0.005;
        spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi + deltaY * 0.005));
        
        updateCameraPosition();
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }
    });
    
    container.addEventListener('mouseup', () => { isDragging = false; });
    container.addEventListener('mouseleave', () => { isDragging = false; });
    
    container.addEventListener('wheel', (e) => {
      e.preventDefault();
      spherical.radius = Math.max(10, Math.min(50, spherical.radius + e.deltaY * 0.05));
      updateCameraPosition();
    }, { passive: false });

    // ============================================
    // PARALLAX EFFECT
    // ============================================
    let mouseX = 0, mouseY = 0;
    let parallaxStrength = 1.5;
    
    document.addEventListener('mousemove', (e) => {
      mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
      mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
    });

    // ============================================
    // POST-PROCESSING (Manual DOF simulation)
    // ============================================
    // Since we can't use EffectComposer without import maps,
    // we'll simulate DOF with material opacity based on distance
    
    let focusDistance = 15;
    let bokehStrength = 0.015;
    let bloomIntensity = 0.8;
    
    function updateDepthEffects() {
      nodeMeshes.forEach(mesh => {
        const dist = camera.position.distanceTo(mesh.position);
        const focusDiff = Math.abs(dist - focusDistance);
        
        // Blur simulation via opacity and emissive
        const blur = Math.min(1, focusDiff * bokehStrength);
        const sharpness = 1 - blur;
        
        mesh.material.opacity = 0.5 + sharpness * 0.5;
        mesh.material.transparent = true;
        mesh.material.emissiveIntensity = 0.3 + (1 - blur) * bloomIntensity * 0.5;
        
        // Scale glow based on focus
        const glow = mesh.children[0];
        if (glow) {
          glow.material.opacity = 0.1 + blur * 0.2;
          glow.scale.setScalar(1 + blur * 0.5);
        }
      });
      
      tubes.forEach(tube => {
        const midpoint = new THREE.Vector3().lerpVectors(
          tube.userData.fromNode.position,
          tube.userData.toNode.position,
          0.5
        );
        const dist = camera.position.distanceTo(midpoint);
        const focusDiff = Math.abs(dist - focusDistance);
        const blur = Math.min(1, focusDiff * bokehStrength);
        
        tube.material.opacity = (0.6 + tube.userData.strength * 0.4) * (1 - blur * 0.5);
        tube.material.emissiveIntensity = (0.2 + tube.userData.strength * 0.3) * (1 - blur * 0.3);
      });
    }

    // ============================================
    // TOOLTIP / HOVER
    // ============================================
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const tooltip = document.getElementById('tooltip');
    let hoveredNode = null;
    
    function updateTooltip(e) {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(nodeMeshes);
      
      if (intersects.length > 0) {
        const node = intersects[0].object;
        const entity = node.userData;
        
        if (hoveredNode !== node) {
          hoveredNode = node;
          
          document.getElementById('tooltip-name').textContent = entity.name;
          document.getElementById('tooltip-role').textContent = entity.role;
          document.getElementById('tooltip-threads').textContent = entity.threads;
          document.getElementById('tooltip-meetings').textContent = entity.meetings;
          document.getElementById('tooltip-response').textContent = entity.response + '%';
          
          // Find connection strength to primary
          const conn = connections.find(c => 
            (c.from === 'pat' && c.to === entity.id) ||
            (c.to === 'pat' && c.from === entity.id)
          );
          document.getElementById('tooltip-strength').textContent = conn ? conn.strength.toFixed(2) : 'N/A';
        }
        
        tooltip.style.left = e.clientX + 15 + 'px';
        tooltip.style.top = e.clientY + 15 + 'px';
        tooltip.classList.add('visible');
        
        // Highlight node
        node.material.emissiveIntensity = 0.8;
        node.scale.setScalar(1.2);
      } else {
        if (hoveredNode) {
          hoveredNode.material.emissiveIntensity = 0.3;
          hoveredNode.scale.setScalar(1);
          hoveredNode = null;
        }
        tooltip.classList.remove('visible');
      }
    }
    
    container.addEventListener('mousemove', updateTooltip);

    // ============================================
    // CONTROLS UI
    // ============================================
    document.getElementById('focusDistance').addEventListener('input', (e) => {
      focusDistance = parseFloat(e.target.value);
      document.getElementById('focusDistanceVal').textContent = focusDistance;
    });
    
    document.getElementById('bokehStrength').addEventListener('input', (e) => {
      bokehStrength = parseFloat(e.target.value);
      document.getElementById('bokehStrengthVal').textContent = bokehStrength.toFixed(3);
    });
    
    document.getElementById('bloomIntensity').addEventListener('input', (e) => {
      bloomIntensity = parseFloat(e.target.value);
      document.getElementById('bloomIntensityVal').textContent = bloomIntensity;
    });
    
    document.getElementById('parallaxStrength').addEventListener('input', (e) => {
      parallaxStrength = parseFloat(e.target.value);
      document.getElementById('parallaxStrengthVal').textContent = parallaxStrength;
    });

    // ============================================
    // ANIMATION LOOP
    // ============================================
    let time = 0;
    
    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;
      
      // Physics update (gradually stabilizes)
      updatePhysics();
      
      // Parallax camera offset
      const parallaxX = mouseX * parallaxStrength;
      const parallaxY = mouseY * parallaxStrength * 0.5;
      camera.position.x += (parallaxX - (camera.position.x - spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta))) * 0.05;
      camera.position.y += (parallaxY + spherical.radius * Math.cos(spherical.phi) - camera.position.y) * 0.05;
      camera.lookAt(0, 0, 0);
      
      // Depth effects
      updateDepthEffects();
      
      // Node subtle animation
      nodeMeshes.forEach((mesh, i) => {
        mesh.rotation.y = time * 0.2 + i;
        mesh.position.y += Math.sin(time * 2 + i) * 0.002;
      });
      
      // Tube glow pulse
      tubes.forEach((tube, i) => {
        tube.material.emissiveIntensity = (0.2 + tube.userData.strength * 0.3) * (0.8 + Math.sin(time * 3 + i) * 0.2);
      });
      
      renderer.render(scene, camera);
    }
    
    // ============================================
    // RESIZE
    // ============================================
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Start
    updateCameraPosition();
    animate();
  </script>
</body>
</html>
